#!/usr/bin/env bash

set -euo pipefail

# Git Worktree Tool (gwt)
# Usage:
#   gwt                    - Interactive: select existing worktree
#   gwt <branch-name>      - Create/switch to worktree for branch
#   gwt <path>             - Switch to existing worktree at path

BRANCH_OR_PATH="${1:-}"

# Ensure we're in a git repository
if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
  echo "Error: Not inside a git repository"
  exit 1
fi

# Get repo info (use git-common-dir to always get main repo, even from inside a worktree)
GIT_COMMON_DIR=$(cd "$(git rev-parse --git-common-dir)" && pwd)
REPO_ROOT=$(dirname "$GIT_COMMON_DIR")
WORKTREES_DIR="$REPO_ROOT/worktrees"
BASE_BRANCH=$(git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@' 2>/dev/null || echo "main")

# Check if we're inside tmux
INSIDE_TMUX=${TMUX:+true}
INSIDE_TMUX=${INSIDE_TMUX:-false}

# Interactive mode - select existing worktree
if [ -z "$BRANCH_OR_PATH" ]; then
  # Use fzf to select existing worktree
  if ! command -v fzf >/dev/null 2>&1; then
    echo "Error: fzf not found. Install fzf for interactive mode or specify a branch name."
    exit 1
  fi

  # Get all worktrees with their branches for fzf selection
  WORKTREE_SELECTION=$(git worktree list | fzf --prompt="Select worktree: " --height=10 --delimiter=' ' --with-nth=1,3)

  if [ -z "$WORKTREE_SELECTION" ]; then
    echo "No worktree selected"
    exit 0
  fi

  # Extract the path (first field) from the selection
  WORKTREE_PATH=$(echo "$WORKTREE_SELECTION" | awk '{print $1}')
  WINDOW_NAME=$(basename "$WORKTREE_PATH")
else
  # Check if it's an existing path
  if [ -d "$WORKTREES_DIR/$BRANCH_OR_PATH" ]; then
    # Existing worktree
    WORKTREE_PATH="$WORKTREES_DIR/$BRANCH_OR_PATH"
    WINDOW_NAME="$BRANCH_OR_PATH"
    echo "Switching to existing worktree: $WORKTREE_PATH"
  else
    # Ask user: new branch or existing?
    echo "Worktree '$BRANCH_OR_PATH' doesn't exist."
    echo "1) New branch (an/$BRANCH_OR_PATH)"
    echo "2) Existing branch"
    read -p "Choice [1/2]: " -n 1 -r BRANCH_CHOICE
    echo

    if [[ "$BRANCH_CHOICE" == "2" ]]; then
      # Existing branch - use fzf to select
      if ! command -v fzf >/dev/null 2>&1; then
        echo "Error: fzf not found."
        exit 1
      fi

      # List all branches (local + remote), filter with provided name
      SELECTED_BRANCH=$(git branch -a --format='%(refname:short)' | \
        sed 's|^origin/||' | \
        sort -u | \
        grep -v '^HEAD$' | \
        fzf --prompt="Select branch: " --query="$BRANCH_OR_PATH" --height=15)

      if [ -z "$SELECTED_BRANCH" ]; then
        echo "No branch selected"
        exit 0
      fi

      # Normalize for path
      NORMALIZED_BRANCH=$(echo "$SELECTED_BRANCH" | sed 's|/|_|g' | sed 's/[^a-zA-Z0-9_-]/-/g')
      WORKTREE_PATH="$WORKTREES_DIR/$NORMALIZED_BRANCH"
      WINDOW_NAME="$NORMALIZED_BRANCH"

      echo "Creating worktree for existing branch: $SELECTED_BRANCH"
      echo "Path: $WORKTREE_PATH"

      mkdir -p "$WORKTREES_DIR"
      git worktree add "$WORKTREE_PATH" "$SELECTED_BRANCH"
    else
      # New branch (default)
      NORMALIZED_BRANCH=$(echo "$BRANCH_OR_PATH" | sed 's/[^a-zA-Z0-9_-]/-/g')
      FULL_BRANCH_NAME="an/$NORMALIZED_BRANCH"
      WORKTREE_PATH="$WORKTREES_DIR/$NORMALIZED_BRANCH"
      WINDOW_NAME="$NORMALIZED_BRANCH"

      echo "Creating worktree for: $BRANCH_OR_PATH"
      echo "Branch: $FULL_BRANCH_NAME"
      echo "Path: $WORKTREE_PATH"

      mkdir -p "$WORKTREES_DIR"
      git worktree add -b "$FULL_BRANCH_NAME" "$WORKTREE_PATH" "$BASE_BRANCH"
    fi

    # Ask if user wants to copy ignored files
    echo
    read -p "Copy ignored files? [y/N]: " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
      # Check if fzf is available for interactive selection
      if ! command -v fzf >/dev/null 2>&1; then
        echo "Error: fzf not found. Install fzf to select files interactively."
        exit 1
      fi

      echo "Finding git-ignored files..."
      cd "$REPO_ROOT"

      # Get all git-ignored files that actually exist
      # This uses git status --ignored to find all ignored files
      IGNORED_FILES=$(git status --ignored --porcelain | grep '^!!' | sed 's/^!! //' | sort)

      if [ -z "$IGNORED_FILES" ]; then
        echo "No git-ignored files found in the repository."
      else
        echo
        echo "Select files/directories to copy (use TAB to select multiple, ENTER when done):"
        echo

        # Use fzf for multi-select
        SELECTED_FILES=$(echo "$IGNORED_FILES" | fzf --multi --prompt="Select files to copy: " --height=50% --border)

        if [ -n "$SELECTED_FILES" ]; then
          echo
          echo "Copying selected files..."

          while IFS= read -r item; do
            if [ -e "$item" ]; then
              echo "  Copying $item..."
              if [ -d "$item" ]; then
                # For directories, copy recursively
                cp -Rc "$item" "$WORKTREE_PATH/"
              else
                # For files, ensure parent directory exists
                mkdir -p "$WORKTREE_PATH/$(dirname "$item")"
                cp -c "$item" "$WORKTREE_PATH/$item"
              fi
            fi
          done <<< "$SELECTED_FILES"

          echo "Done copying ignored files."
        else
          echo "No files selected."
        fi
      fi
    fi
  fi
fi

# Tmux integration
setup_tmux_window() {
  local window_name="$1"
  local worktree_path="$2"

  if [ "$INSIDE_TMUX" = true ]; then
    # Create new window in current session
    tmux new-window -c "$worktree_path" -n "$window_name"
  else
    # Create new session and attach
    tmux new-session -c "$worktree_path" -s "$window_name" -d
    tmux attach-session -t "$window_name"
    return
  fi
}

# Set up tmux window and change directory
setup_tmux_window "$WINDOW_NAME" "$WORKTREE_PATH"

echo "Switched to worktree: $WORKTREE_PATH"

