#!/usr/bin/env zx

import { $, fs, glob, path } from 'zx'
import ora from 'ora'
import prompts from 'prompts'
import minimist from 'minimist'

const argv = minimist(process.argv.slice(3))

// Git Worktree Tool — run `wt` for usage

$.quiet = true

const command = argv._[0]

if (!command || !['new', 'switch', 'rm'].includes(command)) {
  console.log('')
  console.log('Usage:')
  console.log('  wt new [name] [branch]  - Create a new worktree')
  console.log('  wt switch               - Switch to existing worktree')
  console.log('  wt rm                   - Remove a worktree')
  process.exit(1)
}

// Ensure we're in a git repository
try {
  await $`git rev-parse --is-inside-work-tree`
} catch {
  console.log('Error: Not inside a git repository')
  process.exit(1)
}

// Get repo info
const gitCommonDir = (await $`cd "$(git rev-parse --git-common-dir)" && pwd`).stdout.trim()
const repoRoot = path.dirname(gitCommonDir)
const repoName = path.basename(repoRoot)
const parentDir = path.dirname(repoRoot)

let baseBranch
try {
  baseBranch = (await $`git symbolic-ref refs/remotes/origin/HEAD`).stdout.trim().replace('refs/remotes/origin/', '')
} catch {
  baseBranch = 'main'
}

const insideTmux = !!process.env.TMUX

let worktreePath
let windowName

if (command === 'switch') {
  const worktreeList = (await $`git worktree list`).stdout.trim()

  let selection
  try {
    selection = (await $`echo ${worktreeList} | fzf --prompt="Select worktree: " --height=10 --delimiter=' ' --with-nth=1,3`).stdout.trim()
  } catch {
    console.log('No worktree selected')
    process.exit(0)
  }

  worktreePath = selection.split(/\s+/)[0]
  windowName = path.basename(worktreePath)
}

if (command === 'rm') {
  const worktreeList = (await $`git worktree list`).stdout.trim()
  const lines = worktreeList.split('\n')

  // Filter out main worktree (first line)
  const removable = lines.slice(1).join('\n')
  if (!removable.trim()) {
    console.log('No removable worktrees (main worktree cannot be removed)')
    process.exit(0)
  }

  let selection
  try {
    selection = (await $`echo ${removable} | fzf --prompt="Remove worktree: " --height=10 --delimiter=' ' --with-nth=1,3`).stdout.trim()
  } catch {
    console.log('No worktree selected')
    process.exit(0)
  }

  const wtPath = selection.split(/\s+/)[0]
  const wtName = path.basename(wtPath)

  // Check for uncommitted changes
  const status = (await $`git -C ${wtPath} status --porcelain`).stdout.trim()
  if (status) {
    console.log(`\nWorktree has uncommitted changes:\n`)
    console.log(status)
    console.log('')

    const { showDiff } = await prompts({
      type: 'confirm',
      name: 'showDiff',
      message: 'Show full diff?',
      initial: false
    })

    if (showDiff) {
      await $({ stdio: 'inherit' })`git -C ${wtPath} diff`
      console.log('')
    }
  }

  const { confirmed } = await prompts({
    type: 'confirm',
    name: 'confirmed',
    message: `Remove worktree "${wtName}"?`,
    initial: false
  })

  if (!confirmed) {
    process.exit(0)
  }

  await $`git worktree remove ${wtPath} --force`.catch(() => {})
  await fs.remove(wtPath)
  console.log(`Removed worktree: ${wtPath}`)

  // Kill tmux window whose pane cwd matches the worktree path
  if (insideTmux) {
    try {
      const panes = (await $`tmux list-panes -a -F ${'#{session_name}:#{window_index} #{pane_current_path}'}`).stdout.trim()
      for (const line of panes.split('\n')) {
        const [windowTarget, panePath] = [line.split(' ')[0], line.split(' ').slice(1).join(' ')]
        if (panePath.startsWith(wtPath)) {
          await $`tmux kill-window -t ${windowTarget}`
          console.log(`Killed tmux window: ${windowTarget}`)
          break
        }
      }
    } catch {}
  }

  process.exit(0)
}

if (command === 'new') {
  let name = argv._[1]
  if (!name) {
    const response = await prompts({
      type: 'text',
      name: 'name',
      message: 'Worktree name'
    })
    name = response.name
  }
  if (!name?.trim()) {
    console.log('Name required')
    process.exit(1)
  }

  let normalizedName = name.trim().replace(/[^a-zA-Z0-9_-]/g, '-')
  worktreePath = `${parentDir}/${repoName}--${normalizedName}`

  // Check if worktree path already exists
  if (fs.existsSync(worktreePath)) {
    const { action } = await prompts({
      type: 'select',
      name: 'action',
      message: `Path "${worktreePath}" exists`,
      choices: [
        { title: 'Remove existing', value: 'remove' },
        { title: 'Enter new name', value: 'rename' },
        { title: 'Abort', value: 'abort' }
      ]
    })
    if (action === 'remove') {
      await $`git worktree remove ${worktreePath} --force`.catch(() => { })
      await fs.remove(worktreePath)
    } else if (action === 'rename') {
      const { newName } = await prompts({
        type: 'text',
        name: 'newName',
        message: 'New worktree name'
      })
      if (!newName?.trim()) {
        console.log('Name required')
        process.exit(1)
      }
      normalizedName = newName.trim().replace(/[^a-zA-Z0-9_-]/g, '-')
      worktreePath = `${parentDir}/${repoName}--${normalizedName}`
    } else {
      process.exit(0)
    }
  }

  windowName = normalizedName
  const defaultBranch = `an/${normalizedName}`
  let branchName = argv._[2] || defaultBranch

  // Check if branch already exists
  let branchExists = false
  try {
    await $`git rev-parse --verify ${branchName}`
    branchExists = true
  } catch { }

  if (branchExists) {
    const { action } = await prompts({
      type: 'select',
      name: 'action',
      message: `Branch "${branchName}" already exists`,
      choices: [
        { title: 'Use existing branch', value: 'use' },
        { title: 'Enter new branch name', value: 'new' }
      ]
    })
    if (action === 'new') {
      const { newBranch } = await prompts({
        type: 'text',
        name: 'newBranch',
        message: 'New branch name'
      })
      if (!newBranch?.trim()) {
        console.log('Branch name required')
        process.exit(1)
      }
      branchName = newBranch.trim()
      branchExists = false
    }
  }

  console.log(`Creating worktree: ${worktreePath}`)
  console.log(`Branch: ${branchName}`)

  await fs.ensureDir(parentDir)
  $.quiet = false
  if (branchExists) {
    await $`git worktree add ${worktreePath} ${branchName}`
  } else {
    await $`git worktree add -b ${branchName} ${worktreePath} ${baseBranch}`
  }
  $.quiet = true

  // Copy files from .worktree-setup
  const includesFile = `${repoRoot}/.worktree-setup`
  if (!fs.existsSync(includesFile)) {
    console.log('')
    console.log('Error: .worktree-setup not found')
    console.log('')
    console.log('This file lists paths to copy into new worktrees (e.g. .env, node_modules).')
    console.log(`Create it at: ${includesFile}`)
    console.log('')
    console.log('Example contents:')
    console.log('  .env')
    console.log('  .env.local')
    console.log('  $ pnpm install')
    console.log('')
    console.log(`To create an empty one: touch ${includesFile}`)
    process.exit(1)
  }

  const lines = fs.readFileSync(includesFile, 'utf-8')
    .split('\n')
    .map(line => line.trim())
    .filter(line => line && !line.startsWith('#'))

  const filesToCopy = lines.filter(line => !line.startsWith('$'))
  const commands = lines.filter(line => line.startsWith('$')).map(line => line.slice(1).trim())

  if (filesToCopy.length > 0) {
    console.log('Copying files from .worktree-setup...')
    for (const pattern of filesToCopy) {
      if (pattern.includes('*')) {
        // Glob pattern - find matching paths
        const matches = await glob(pattern, { cwd: repoRoot, dot: true })
        for (const match of matches) {
          const srcPath = `${repoRoot}/${match}`
          const destPath = `${worktreePath}/${match}`
          console.log(`  Copying ${match}...`)
          await fs.ensureDir(path.dirname(destPath))
          await fs.copy(srcPath, destPath)
        }
        if (matches.length === 0) {
          console.log(`  Warning: no matches for ${pattern}`)
        }
      } else {
        // Direct path
        const srcPath = `${repoRoot}/${pattern}`
        if (fs.existsSync(srcPath)) {
          console.log(`  Copying ${pattern}...`)
          const destPath = `${worktreePath}/${pattern}`
          await fs.ensureDir(path.dirname(destPath))
          await fs.copy(srcPath, destPath)
        } else {
          console.log(`  Warning: ${pattern} not found, skipping`)
        }
      }
    }
  }

  if (commands.length > 0) {
    console.log('Running setup commands...')
    for (const cmd of commands) {
      const s = ora(`  $ ${cmd}`).start()
      try {
        await $({ cwd: worktreePath, quiet: true })`${cmd.split(/\s+/)}`
        s.succeed()
      } catch (e) {
        s.fail(`  $ ${cmd} — ${e.message}`)
      }
    }
  }
}

// Tmux integration
if (!insideTmux) {
  console.log('Error: Must be run inside tmux')
  process.exit(1)
}

// Create new window with claude on left, nvim top-right, terminal bottom-right
await $`tmux new-window -c ${worktreePath} -n ${windowName} claude`
await $`sleep 1 && tmux send-keys -t ${windowName}.0 Enter`
await $`tmux split-window -h -c ${worktreePath} -l 60% nvim`
await $`tmux split-window -v -c ${worktreePath} -l 30%`
console.log(`Switched to worktree: ${worktreePath}`)
